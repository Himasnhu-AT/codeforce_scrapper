{
    "title": "D. Treasure Hunting",
    "timeLimit": {
        "value": 3.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>You are on the island which can be represented as a $$$n \\times m$$$ table. The rows are numbered from $$$1$$$ to $$$n$$$ and the columns are numbered from $$$1$$$ to $$$m$$$. There are $$$k$$$ treasures on the island, the $$$i$$$-th of them is located at the position $$$(r_i, c_i)$$$.</p><p>Initially you stand at the lower left corner of the island, at the position $$$(1, 1)$$$. If at any moment you are at the cell with a treasure, you can pick it up without any extra time. In one move you can move up (from $$$(r, c)$$$ to $$$(r+1, c)$$$), left (from $$$(r, c)$$$ to $$$(r, c-1)$$$), or right (from position $$$(r, c)$$$ to $$$(r, c+1)$$$). Because of the traps, you can't move down.</p><p>However, moving up is also risky. You can move up only if you are in a safe column. There are $$$q$$$ safe columns: $$$b_1, b_2, \\ldots, b_q$$$. You want to collect all the treasures as fast as possible. Count the minimum number of moves required to collect all the treasures.</p>",
    "inputSpecification": "<p>The first line contains integers $$$n$$$, $$$m$$$, $$$k$$$ and $$$q$$$ ($$$2 \\le n, \\, m, \\, k, \\, q \\le 2 \\cdot 10^5$$$, $$$q \\le m$$$)\u00a0\u2014 the number of rows, the number of columns, the number of treasures in the island and the number of safe columns.</p><p>Each of the next $$$k$$$ lines contains two integers $$$r_i, c_i$$$, ($$$1 \\le r_i \\le n$$$, $$$1 \\le c_i \\le m$$$)\u00a0\u2014 the coordinates of the cell with a treasure. All treasures are located in distinct cells.</p><p>The last line contains $$$q$$$ distinct integers $$$b_1, b_2, \\ldots, b_q$$$ ($$$1 \\le b_i \\le m$$$) \u2014 the indices of safe columns.</p>",
    "outputSpecification": "<p>Print the minimum number of moves required to collect all the treasures.</p>",
    "samples": [
        {
            "input": "\n3 3 3 2\n1 1\n2 1\n3 1\n2 3\n",
            "output": "\n6"
        },
        {
            "input": "\n3 5 3 2\n1 2\n2 3\n3 1\n1 5\n",
            "output": "\n8"
        },
        {
            "input": "\n3 6 3 2\n1 6\n2 2\n3 4\n1 6\n",
            "output": "\n15"
        }
    ],
    "note": "<p>In the first example you should use the second column to go up, collecting in each row treasures from the first column.</p><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/f371e8d90534e1f0144b887c212c995dba163e4e.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> </center><p>In the second example, it is optimal to use the first column to go up.</p><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/c90a522bfb833b81bb69a56ded89c9abeffc1aff.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> </center><p>In the third example, it is optimal to collect the treasure at cell $$$(1;6)$$$, go up to row $$$2$$$ at column $$$6$$$, then collect the treasure at cell $$$(2;2)$$$, go up to the top row at column $$$1$$$ and collect the last treasure at cell $$$(3;4)$$$. That's a total of $$$15$$$ moves.</p><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/907114a4ab6702a4dfdf36772af8e085d0dcd581.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> </center>",
    "contestId": 1201,
    "index": "D",
    "name": "Treasure Hunting",
    "type": "PROGRAMMING",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "implementation"
    ],
    "solvedCount": 2301
}