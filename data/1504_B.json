{
    "title": "B. Flip the Bits",
    "timeLimit": {
        "value": 1.0,
        "unit": "second"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>There is a binary string $$$a$$$ of length $$$n$$$. In one operation, you can select any prefix of $$$a$$$ with an <span class=\"tex-font-style-bf\">equal</span> number of $$$0$$$ and $$$1$$$ symbols. Then all symbols in the prefix are inverted: each $$$0$$$ becomes $$$1$$$ and each $$$1$$$ becomes $$$0$$$.</p><p>For example, suppose $$$a=0111010000$$$. </p><ul> <li> In the first operation, we can select the prefix of length $$$8$$$ since it has four $$$0$$$'s and four $$$1$$$'s: $$$[01110100]00\\to [10001011]00$$$. </li><li> In the second operation, we can select the prefix of length $$$2$$$ since it has one $$$0$$$ and one $$$1$$$: $$$[10]00101100\\to [01]00101100$$$. </li><li> It is illegal to select the prefix of length $$$4$$$ for the third operation, because it has three $$$0$$$'s and one $$$1$$$. </li></ul><p>Can you transform the string $$$a$$$ into the string $$$b$$$ using some finite number of operations (possibly, none)?</p>",
    "inputSpecification": "<p>The first line contains a single integer $$$t$$$ ($$$1\\le t\\le 10^4$$$) \u2014 the number of test cases.</p><p>The first line of each test case contains a single integer $$$n$$$ ($$$1\\le n\\le 3\\cdot 10^5$$$) \u2014 the length of the strings $$$a$$$ and $$$b$$$.</p><p>The following two lines contain strings $$$a$$$ and $$$b$$$ of length $$$n$$$, consisting of symbols $$$0$$$ and $$$1$$$.</p><p>The sum of $$$n$$$ across all test cases does not exceed $$$3\\cdot 10^5$$$.</p>",
    "outputSpecification": "<p>For each test case, output \"<span class=\"tex-font-style-tt\">YES</span>\" if it is possible to transform $$$a$$$ into $$$b$$$, or \"<span class=\"tex-font-style-tt\">NO</span>\" if it is impossible. You can print each letter in any case (upper or lower).</p>",
    "samples": [
        {
            "input": "\n5\n10\n0111010000\n0100101100\n4\n0000\n0000\n3\n001\n000\n12\n010101010101\n100110011010\n6\n000111\n110100\n",
            "output": "\nYES\nYES\nNO\nYES\nNO\n"
        }
    ],
    "note": "<p>The first test case is shown in the statement.</p><p>In the second test case, we transform $$$a$$$ into $$$b$$$ by using zero operations.</p><p>In the third test case, there is no legal operation, so it is impossible to transform $$$a$$$ into $$$b$$$.</p><p>In the fourth test case, here is one such transformation: </p><ul> <li> Select the length $$$2$$$ prefix to get $$$100101010101$$$. </li><li> Select the length $$$12$$$ prefix to get $$$011010101010$$$. </li><li> Select the length $$$8$$$ prefix to get $$$100101011010$$$. </li><li> Select the length $$$4$$$ prefix to get $$$011001011010$$$. </li><li> Select the length $$$6$$$ prefix to get $$$100110011010$$$. </li></ul><p>In the fifth test case, the only legal operation is to transform $$$a$$$ into $$$111000$$$. From there, the only legal operation is to return to the string we started with, so we cannot transform $$$a$$$ into $$$b$$$.</p>",
    "contestId": 1504,
    "index": "B",
    "name": "Flip the Bits",
    "type": "PROGRAMMING",
    "tags": [
        "constructive algorithms",
        "greedy",
        "implementation",
        "math"
    ],
    "solvedCount": 17549
}