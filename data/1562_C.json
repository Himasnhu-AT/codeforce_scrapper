{
    "title": "C. Rings",
    "timeLimit": {
        "value": 1.0,
        "unit": "second"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<div class=\"epigraph\"><div class=\"epigraph-text\"><span class=\"tex-font-size-small\"> Frodo was caught by Saruman. He tore a pouch from Frodo's neck, shook out its contents\u00a0\u2014there was a pile of different rings: gold and silver...<p>\"How am I to tell which is the One?!\" the mage howled.</p><p>\"Throw them one by one into the Cracks of Doom and watch when Mordor falls!\" </p></span></div></div><p>Somewhere in a parallel Middle-earth, when Saruman caught Frodo, he only found $$$n$$$ rings. And the $$$i$$$-th ring was either gold or silver. For convenience Saruman wrote down a binary string $$$s$$$ of $$$n$$$ characters, where the $$$i$$$-th character was <span class=\"tex-font-style-tt\">0</span> if the $$$i$$$-th ring was gold, and <span class=\"tex-font-style-tt\">1</span> if it was silver.</p><p>Saruman has a magic function $$$f$$$, which takes a binary string and returns a number obtained by converting the string into a binary number and then converting the binary number into a decimal number. For example, $$$f(001010) = 10, f(111) = 7, f(11011101) = 221$$$.</p><p>Saruman, however, thinks that the order of the rings plays some important role. He wants to find $$$2$$$ pairs of integers $$$(l_1, r_1), (l_2, r_2)$$$, such that:</p><ul><li> $$$1 \\le l_1 \\le n$$$, $$$1 \\le r_1 \\le n$$$, $$$r_1-l_1+1\\ge \\lfloor \\frac{n}{2} \\rfloor$$$ </li><li> $$$1 \\le l_2 \\le n$$$, $$$1 \\le r_2 \\le n$$$, $$$r_2-l_2+1\\ge \\lfloor \\frac{n}{2} \\rfloor$$$ </li><li> Pairs $$$(l_1, r_1)$$$ and $$$(l_2, r_2)$$$ are distinct. That is, at least one of $$$l_1 \\neq l_2$$$ and $$$r_1 \\neq r_2$$$ must hold.</li><li> Let $$$t$$$ be the substring $$$s[l_1:r_1]$$$ of $$$s$$$, and $$$w$$$ be the substring $$$s[l_2:r_2]$$$ of $$$s$$$. Then <span class=\"tex-font-style-bf\">there exists non-negative integer $$$k$$$, such that $$$f(t) = f(w) \\cdot k$$$.</span></li></ul><p>Here substring $$$s[l:r]$$$ denotes $$$s_ls_{l+1}\\ldots s_{r-1}s_r$$$, and $$$\\lfloor x \\rfloor$$$ denotes rounding the number down to the nearest integer.</p><p>Help Saruman solve this problem! It is guaranteed that under the constraints of the problem at least one solution exists.</p>",
    "inputSpecification": "<p>Each test contains multiple test cases.</p><p>The first line contains one positive integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$), denoting the number of test cases. Description of the test cases follows.</p><p>The first line of each test case contains one positive integer $$$n$$$ ($$$2 \\le n \\le 2 \\cdot 10^4$$$)\u00a0\u2014 length of the string.</p><p>The second line of each test case contains a non-empty binary string of length $$$n$$$.</p><p>It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.</p>",
    "outputSpecification": "<p>For every test case print four integers $$$l_1$$$, $$$r_1$$$, $$$l_2$$$, $$$r_2$$$, which denote the beginning of the first substring, the end of the first substring, the beginning of the second substring, and the end of the second substring, respectively.</p><p>If there are multiple solutions, print any.</p>",
    "samples": [
        {
            "input": "\n7\n6\n101111\n9\n111000111\n8\n10000000\n5\n11011\n6\n001111\n3\n101\n30\n100000000000000100000000000000\n",
            "output": "\n3 6 1 3\n1 9 4 9\n5 8 1 4\n1 5 3 5\n1 6 2 4\n1 2 2 3\n1 15 16 30"
        }
    ],
    "note": "<p>In the first testcase $$$f(t) = f(1111) = 15$$$, $$$f(w) = f(101) = 5$$$.</p><p>In the second testcase $$$f(t) = f(111000111) = 455$$$, $$$f(w) = f(000111) = 7$$$.</p><p>In the third testcase $$$f(t) = f(0000) = 0$$$, $$$f(w) = f(1000) = 8$$$.</p><p>In the fourth testcase $$$f(t) = f(11011) = 27$$$, $$$f(w) = f(011) = 3$$$.</p><p>In the fifth testcase $$$f(t) = f(001111) = 15$$$, $$$f(w) = f(011) = 3$$$.</p>",
    "contestId": 1562,
    "index": "C",
    "name": "Rings",
    "type": "PROGRAMMING",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "solvedCount": 12986
}