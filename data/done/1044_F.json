{
    "title": "F. DFS",
    "timeLimit": {
        "value": 6.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 512.0,
        "unit": "megabytes"
    },
    "statement": "<p>Let $$$T$$$ be a tree on $$$n$$$ vertices. Consider a graph $$$G_0$$$, initially equal to $$$T$$$. You are given a sequence of $$$q$$$ updates, where the $$$i$$$-th update is given as a pair of two distinct integers $$$u_i$$$ and $$$v_i$$$. </p><p>For every $$$i$$$ from $$$1$$$ to $$$q$$$, we define the graph $$$G_i$$$ as follows: </p><ul> <li> If $$$G_{i-1}$$$ contains an edge $$$\\{u_i, v_i\\}$$$, then remove this edge to form $$$G_i$$$. </li><li> Otherwise, add this edge to $$$G_{i-1}$$$ to form $$$G_i$$$. </li></ul> <p>Formally, $$$G_i := G_{i-1} \\triangle \\{\\{u_i, v_i\\}\\}$$$ where $$$\\triangle$$$ denotes the set <a href=\"https://en.wikipedia.org/wiki/Symmetric_difference\">symmetric difference</a>. </p><p>Furthermore, it is guaranteed that $$$T$$$ is always a subgraph of $$$G_i$$$. In other words, an update never removes an edge of $$$T$$$.</p><p>Consider a connected graph $$$H$$$ and run a depth-first search on it. One can see that the tree edges (i.e. the edges leading to a not yet visited vertex at the time of traversal) form a spanning tree of the graph $$$H$$$. This spanning tree is not generally fixed for a particular graph\u00a0\u2014 it depends on the starting vertex, and on the order in which the neighbors of each vertex are traversed. </p><p>We call vertex $$$w$$$ <span class=\"tex-font-style-it\">good</span> if one can order the neighbors of each vertex in such a way that the depth-first search started from $$$w$$$ produces $$$T$$$ as the spanning tree. For every $$$i$$$ from $$$1$$$ to $$$q$$$, find and report the number of good vertices.</p>",
    "inputSpecification": "<p>The first line contains two integers $$$n$$$ and $$$q$$$ ($$$3 \\le n \\le 2\\cdot 10^5$$$, $$$1 \\le q \\le 2 \\cdot 10^5$$$)\u00a0\u2014 the number of nodes and the number of updates, respectively.</p><p>Each of the next $$$n-1$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$)\u00a0\u2014 vertices connected by an edge in $$$T$$$. It is guaranteed that this graph is a tree.</p><p>Each of the next $$$q$$$ lines contains two integers $$$u$$$ and $$$v$$$ ($$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$)\u00a0\u2014 the endpoints of the edge that is added or removed. It is guaranteed that this edge does not belong to $$$T$$$.</p>",
    "outputSpecification": "<p>For each update, print one integer $$$k$$$\u00a0\u2014 the number of good vertices $$$w$$$ after the corresponding update.</p>",
    "samples": [
        {
            "input": "3 2<br/>1 2<br/>1 3<br/>2 3<br/>3 2<br/>",
            "output": "2<br/>3<br/>"
        },
        {
            "input": "6 6<br/>1 2<br/>2 3<br/>1 4<br/>4 5<br/>1 6<br/>2 5<br/>3 4<br/>5 2<br/>6 4<br/>3 4<br/>6 5<br/>",
            "output": "3<br/>2<br/>3<br/>2<br/>3<br/>2<br/>"
        }
    ],
    "note": "<p>The first sample is depicted in the following figure.</p><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/e8199c96597ce0c99d94f7a2fe53457ba87d0afb.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> </center><p>After the first update, $$$G$$$ contains all three possible edges. The result of a DFS is as follows: </p><ul> <li> Let the starting vertex be $$$1$$$. We have two choices of ordering the neighbors of $$$1$$$, either $$$[2, 3]$$$ or $$$[3, 2]$$$. <ul> <li> If we choose the former, then we reach vertex $$$2$$$. Regardless of the ordering of its neighbors, the next visited vertex will be $$$3$$$. Thus, the spanning tree generated by this DFS will contain edges $$$\\{1, 2\\}$$$ and $$$\\{2, 3\\}$$$, which does not equal to $$$T$$$. </li><li> If we choose the latter, we obtain a spanning tree with edges $$$\\{1, 3\\}$$$ and $$$\\{2, 3\\}$$$. </li></ul> Hence, there is no way of ordering the neighbors of vertices such that the DFS produces $$$T$$$, and subsequently $$$1$$$ is not a good vertex. </li><li> Let the starting vertex be $$$2$$$. We have two choices of traversing its neighbors. If we visit $$$3$$$ first, then the spanning tree will consist of edges $$$\\{2,3\\}$$$ and $$$\\{1,3\\}$$$, which is not equal to $$$T$$$. If we, however, visit $$$1$$$ first, then we can only continue to $$$3$$$ from here, and the spanning tree will consist of edges $$$\\{1, 2\\}$$$ and $$$\\{1,3\\}$$$, which equals to $$$T$$$. Hence, $$$2$$$ is a good vertex. </li><li> The case when we start in the vertex $$$3$$$ is symmetrical to starting in $$$2$$$, and hence $$$3$$$ is a good vertex. </li></ul> Therefore, the answer is $$$2$$$.<p>After the second update, the edge between $$$2$$$ and $$$3$$$ is removed, and $$$G = T$$$. It follows that the spanning tree generated by DFS will be always equal to $$$T$$$ independent of the choice of the starting vertex. Thus, the answer is $$$3$$$.</p><p>In the second sample, the set of good vertices after the corresponding query is: </p><ul> <li> $$$\\{2, 3, 5\\}$$$ </li><li> $$$\\{3, 5\\}$$$ </li><li> $$$\\{3, 4, 5\\}$$$ </li><li> $$$\\{4, 5\\}$$$ </li><li> $$$\\{4, 5, 6\\}$$$ </li><li> $$$\\{5, 6\\}$$$ </li></ul>",
    "contestId": 1044,
    "index": "F",
    "name": "DFS",
    "type": "PROGRAMMING",
    "tags": [
        "data structures"
    ],
    "solvedCount": 507
}