{
    "title": "C. Petya and Tree",
    "timeLimit": {
        "value": 3.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>One night, having had a hard day at work, Petya saw a nightmare. There was a binary search tree in the dream. But it was not the actual tree that scared Petya. The horrifying thing was that Petya couldn't search for elements in this tree. Petya tried many times to choose key and look for it in the tree, and each time he arrived at a wrong place. Petya has been racking his brains for long, choosing keys many times, but the result was no better. But the moment before Petya would start to despair, he had an epiphany: every time he was looking for keys, the tree didn't have the key, and occured exactly one mistake. \"That's not a problem!\", thought Petya. \"Why not count the expectation value of an element, which is found when I search for the key\". The moment he was about to do just that, however, Petya suddenly woke up.</p><p>Thus, you are given a <span class=\"tex-font-style-underline\">binary search tree</span>, that is a tree containing some number written in the node. This number is called the <span class=\"tex-font-style-underline\">node key</span>. The number of children of every node of the tree is equal either to <span class=\"tex-span\">0</span> or to <span class=\"tex-span\">2</span>. The nodes that have <span class=\"tex-span\">0</span> children are called <span class=\"tex-font-style-underline\">leaves</span> and the nodes that have <span class=\"tex-span\">2</span> children, are called <span class=\"tex-font-style-underline\">inner</span>. An inner node has the <span class=\"tex-font-style-underline\">left child</span>, that is the child whose key is less than the current node's key, and the <span class=\"tex-font-style-underline\">right child</span>, whose key is more than the current node's key. Also, a key of any node is strictly larger than all the keys of the left subtree of the node and strictly smaller than all the keys of the right subtree of the node.</p><p>Also you are given a set of <span class=\"tex-font-style-underline\">search keys</span>, all of which are distinct and differ from the node keys contained in the tree. For each key from the set its search in the tree is realised. The search is arranged like this: initially we are located in the tree root, if the key of the current node is larger that our search key, then we move to the left child of the node, otherwise we go to the right child of the node and the process is repeated. As it is guaranteed that the search key is not contained in the tree, the search will always finish in some leaf. The key lying in the leaf is declared the <span class=\"tex-font-style-underline\">search result</span>.</p><p>It is known for sure that during the search we make a mistake in comparing exactly once, that is we go the wrong way, but we won't make any mistakes later. All possible mistakes are equiprobable, that is we should consider all such searches where exactly one mistake occurs. Your task is to find the expectation (the average value) of the search result for every search key, considering that exactly one mistake occurs in the search. That is, for a set of paths containing exactly one mistake in the given key search, you should count the average value of keys containing in the leaves of those paths.</p>",
    "inputSpecification": "<p>The first line contains an odd integer <span class=\"tex-span\"><i>n</i></span> (<span class=\"tex-span\">3\u2009\u2264\u2009<i>n</i>\u2009&lt;\u200910<sup class=\"upper-index\">5</sup></span>), which represents the number of tree nodes. Next <span class=\"tex-span\"><i>n</i></span> lines contain node descriptions. The <span class=\"tex-span\">(<i>i</i>\u2009+\u20091)</span>-th line contains two space-separated integers. The first number is the number of parent of the <span class=\"tex-span\"><i>i</i></span>-st node and the second number is the key lying in the <span class=\"tex-span\"><i>i</i></span>-th node. The next line contains an integer <span class=\"tex-span\"><i>k</i></span> (<span class=\"tex-span\">1\u2009\u2264\u2009<i>k</i>\u2009\u2264\u200910<sup class=\"upper-index\">5</sup></span>), which represents the number of keys for which you should count the average value of search results containing one mistake. Next <span class=\"tex-span\"><i>k</i></span> lines contain the actual keys, one key per line.</p><p>All node keys and all search keys are positive integers, not exceeding <span class=\"tex-span\">10<sup class=\"upper-index\">9</sup></span>. All <span class=\"tex-span\"><i>n</i>\u2009+\u2009<i>k</i></span> keys are distinct.</p><p>All nodes are numbered from <span class=\"tex-span\">1</span> to <span class=\"tex-span\"><i>n</i></span>. For the tree root \"-1\" (without the quote) will be given instead of the parent's node number. It is guaranteed that the correct binary search tree is given. For each node except for the root, it could be determined according to its key whether it is the left child or the right one.</p>",
    "outputSpecification": "<p>Print <span class=\"tex-span\"><i>k</i></span> real numbers which are the expectations of answers for the keys specified in the input. The answer should differ from the correct one with the measure of absolute or relative error not exceeding <span class=\"tex-span\">10<sup class=\"upper-index\">\u2009-\u20099</sup></span>.</p>",
    "samples": [
        {
            "input": "7<br/>-1 8<br/>1 4<br/>1 12<br/>2 2<br/>2 6<br/>3 10<br/>3 14<br/>1<br/>1<br/>",
            "output": "8.0000000000<br/>"
        },
        {
            "input": "3<br/>-1 5<br/>1 3<br/>1 7<br/>6<br/>1<br/>2<br/>4<br/>6<br/>8<br/>9<br/>",
            "output": "7.0000000000<br/>7.0000000000<br/>7.0000000000<br/>3.0000000000<br/>3.0000000000<br/>3.0000000000<br/>"
        }
    ],
    "note": "<p>In the first sample the search of key 1 with one error results in two paths in the trees: (1, 2, 5) and (1, 3, 6), in parentheses are listed numbers of nodes from the root to a leaf. The keys in the leaves of those paths are equal to 6 and 10 correspondingly, that's why the answer is equal to 8.</p>",
    "contestId": 85,
    "index": "C",
    "name": "Petya and Tree",
    "type": "PROGRAMMING",
    "tags": [
        "binary search",
        "dfs and similar",
        "probabilities",
        "sortings",
        "trees"
    ],
    "solvedCount": 523
}