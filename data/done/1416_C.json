{
    "title": "C. XOR Inverse",
    "timeLimit": {
        "value": 2.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 512.0,
        "unit": "megabytes"
    },
    "statement": "<p>You are given an array $$$a$$$ consisting of $$$n$$$ non-negative integers. You have to choose a non-negative integer $$$x$$$ and form a new array $$$b$$$ of size $$$n$$$ according to the following rule: for all $$$i$$$ from $$$1$$$ to $$$n$$$, $$$b_i = a_i \\oplus x$$$ ($$$\\oplus$$$ denotes the operation <a href=\"https://en.wikipedia.org/wiki/Bitwise_operation#XOR\">bitwise XOR</a>).</p><p>An inversion in the $$$b$$$ array is a pair of integers $$$i$$$ and $$$j$$$ such that $$$1 \\le i &lt; j \\le n$$$ and $$$b_i &gt; b_j$$$.</p><p>You should choose $$$x$$$ in such a way that the number of inversions in $$$b$$$ is minimized. If there are several options for $$$x$$$ \u2014 output the smallest one.</p>",
    "inputSpecification": "<p>First line contains a single integer $$$n$$$ ($$$1 \\le n \\le 3 \\cdot 10^5$$$) \u2014 the number of elements in $$$a$$$.</p><p>Second line contains $$$n$$$ space-separated integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$ ($$$0 \\le a_i \\le 10^9$$$), where $$$a_i$$$ is the $$$i$$$-th element of $$$a$$$.</p>",
    "outputSpecification": "<p>Output two integers: the minimum possible number of inversions in $$$b$$$, and the minimum possible value of $$$x$$$, which achieves those number of inversions.</p>",
    "samples": [
        {
            "input": "\n4\n0 1 3 2\n",
            "output": "\n1 0\n"
        },
        {
            "input": "\n9\n10 7 9 10 7 5 5 3 5\n",
            "output": "\n4 14\n"
        },
        {
            "input": "\n3\n8 10 3\n",
            "output": "\n0 8\n"
        }
    ],
    "note": "<p>In the first sample it is optimal to leave the array as it is by choosing $$$x = 0$$$.</p><p>In the second sample the selection of $$$x = 14$$$ results in $$$b$$$: $$$[4, 9, 7, 4, 9, 11, 11, 13, 11]$$$. It has $$$4$$$ inversions:</p><ul> <li> $$$i = 2$$$, $$$j = 3$$$; </li><li> $$$i = 2$$$, $$$j = 4$$$; </li><li> $$$i = 3$$$, $$$j = 4$$$; </li><li> $$$i = 8$$$, $$$j = 9$$$. </li></ul><p>In the third sample the selection of $$$x = 8$$$ results in $$$b$$$: $$$[0, 2, 11]$$$. It has no inversions.</p>",
    "contestId": 1416,
    "index": "C",
    "name": "XOR Inverse",
    "type": "PROGRAMMING",
    "tags": [
        "bitmasks",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy",
        "math",
        "sortings",
        "strings",
        "trees"
    ],
    "solvedCount": 4215
}