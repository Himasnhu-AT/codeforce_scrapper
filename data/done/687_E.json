{
    "title": "E. TOF",
    "timeLimit": {
        "value": 1.0,
        "unit": "second"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>Today Pari gave Arya a cool graph problem. Arya wrote a non-optimal solution for it, because he believes in his ability to optimize non-optimal solutions. In addition to being non-optimal, his code was buggy and he tried a lot to optimize it, so the code also became dirty! He keeps getting Time Limit Exceeds and he is disappointed. Suddenly a bright idea came to his mind!</p><p>Here is how his dirty code looks like:</p><pre class=\"verbatim\"><br/>dfs(v)<br/>{<br/>     set count[v] = count[v] + 1<br/>     if(count[v] &lt; 1000)<br/>     {<br/>          foreach u in neighbors[v]<br/>          {<br/>               if(visited[u] is equal to false)<br/>               {<br/>                    dfs(u)<br/>               }<br/>               break<br/>          }<br/>     }<br/>     set visited[v] = true<br/>}<br/><br/>main()<br/>{<br/>     input the digraph()<br/>     TOF()<br/>     foreach 1&lt;=i&lt;=n<br/>     {<br/>          set count[i] = 0 , visited[i] = false<br/>     }<br/>     foreach 1 &lt;= v &lt;= n<br/>     {<br/>          if(visited[v] is equal to false)<br/>          {<br/>               dfs(v)<br/>          }<br/>     }<br/>     ... // And do something cool and magical but we can't tell you what!<br/>}<br/></pre><p>He asks you to write the <span class=\"tex-font-style-underline\">TOF</span> function in order to optimize the running time of the code with minimizing the number of calls of the <span class=\"tex-font-style-underline\">dfs</span> function. The input is a directed graph and in the <span class=\"tex-font-style-underline\">TOF</span> function you have to rearrange the edges of the graph in the list <span class=\"tex-font-style-underline\">neighbors</span> for each vertex. The number of calls of <span class=\"tex-font-style-underline\">dfs</span> function depends on the arrangement of <span class=\"tex-font-style-underline\">neighbors</span> of each vertex.</p>",
    "inputSpecification": "<p>The first line of the input contains two integers <span class=\"tex-span\"><i>n</i></span> and <span class=\"tex-span\"><i>m</i></span> (<span class=\"tex-span\">1\u2009\u2264\u2009<i>n</i>,\u2009<i>m</i>\u2009\u2264\u20095000</span>)\u00a0\u2014 the number of vertices and then number of directed edges in the input graph.</p><p>Each of the next <span class=\"tex-span\"><i>m</i></span> lines contains a pair of integers <span class=\"tex-span\"><i>u</i><sub class=\"lower-index\"><i>i</i></sub></span> and <span class=\"tex-span\"><i>v</i><sub class=\"lower-index\"><i>i</i></sub></span> (<span class=\"tex-span\">1\u2009\u2009\u2264\u2009\u2009<i>u</i><sub class=\"lower-index\"><i>i</i></sub>,\u2009\u2009<i>v</i><sub class=\"lower-index\"><i>i</i></sub>\u2009\u2009\u2264\u2009\u2009<i>n</i></span>), meaning there is a directed <img align=\"middle\" class=\"tex-formula\" src=\"https://espresso.codeforces.com/c20f40f5f7e1e2baecd80691a3bb1d072198563d.png\" style=\"max-width: 100.0%;max-height: 100.0%;\"/> edge in the input graph. </p><p>You may assume that the graph won't contain any self-loops and there is at most one edge between any unordered pair of vertices.</p>",
    "outputSpecification": "<p>Print a single integer\u00a0\u2014 the minimum possible number of <span class=\"tex-font-style-underline\">dfs</span> calls that can be achieved with permuting the edges.</p>",
    "samples": [
        {
            "input": "<br/>dfs(v)<br/>{<br/>     set count[v] = count[v] + 1<br/>     if(count[v] < 1000)<br/>     {<br/>          foreach u in neighbors[v]<br/>          {<br/>               if(visited[u] is equal to false)<br/>               {<br/>                    dfs(u)<br/>               }<br/>               break<br/>          }<br/>     }<br/>     set visited[v] = true<br/>}<br/><br/>main()<br/>{<br/>     input the digraph()<br/>     TOF()<br/>     foreach 1<=i<=n<br/>     {<br/>          set count[i] = 0 , visited[i] = false<br/>     }<br/>     foreach 1 <= v <= n<br/>     {<br/>          if(visited[v] is equal to false)<br/>          {<br/>               dfs(v)<br/>          }<br/>     }<br/>     ... // And do something cool and magical but we can't tell you what!<br/>}<br/>",
            "output": "3 3<br/>1 2<br/>2 3<br/>3 1<br/>"
        },
        {
            "input": "2998<br/>",
            "output": "6 7<br/>1 2<br/>2 3<br/>3 1<br/>3 4<br/>4 5<br/>5 6<br/>6 4<br/>"
        }
    ],
    "note": null,
    "contestId": 687,
    "index": "E",
    "name": "TOF",
    "type": "PROGRAMMING",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "solvedCount": 316
}