{
    "title": "C. AquaMoon and Permutations",
    "timeLimit": {
        "value": 2.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>Cirno has prepared $$$n$$$ arrays of length $$$n$$$ each. Each array is a permutation of $$$n$$$ integers from $$$1$$$ to $$$n$$$. These arrays are special: for all $$$1 \\leq i \\leq n$$$, if we take the $$$i$$$-th element of each array and form another array of length $$$n$$$ with these elements, the resultant array is also a permutation of $$$n$$$ integers from $$$1$$$ to $$$n$$$. In the other words, if you put these $$$n$$$ arrays under each other to form a matrix with $$$n$$$ rows and $$$n$$$ columns, this matrix is a <a href=\"https://en.wikipedia.org/wiki/Latin_square\">Latin square</a>.</p><p>Afterwards, Cirno added additional $$$n$$$ arrays, each array is a permutation of $$$n$$$ integers from $$$1$$$ to $$$n$$$. For all $$$1 \\leq i \\leq n$$$, there exists <span class=\"tex-font-style-bf\">at least one</span> position $$$1 \\leq k \\leq n$$$, such that for the $$$i$$$-th array and the $$$(n + i)$$$-th array, the $$$k$$$-th element of both arrays is the same. Notice that the arrays indexed from $$$n + 1$$$ to $$$2n$$$ <span class=\"tex-font-style-bf\">don't have to</span> form a Latin square. </p><p>Also, Cirno made sure that for all $$$2n$$$ arrays, no two arrays are completely equal, i.\u00a0e. for all pair of indices $$$1 \\leq i &lt; j \\leq 2n$$$, there exists <span class=\"tex-font-style-bf\">at least one</span> position $$$1 \\leq k \\leq n$$$, such that the $$$k$$$-th elements of the $$$i$$$-th and $$$j$$$-th array are <span class=\"tex-font-style-bf\">different</span>.</p><p>Finally, Cirno arbitrarily changed the order of $$$2n$$$ arrays.</p><p>AquaMoon calls a subset of all $$$2n$$$ arrays of size $$$n$$$ <span class=\"tex-font-style-bf\">good</span> if these arrays from a Latin square.</p><p>AquaMoon wants to know how many good subsets exist. Because this number may be particularly large, find it modulo $$$998\\,244\\,353$$$. Also, she wants to find any good subset. Can you help her?</p>",
    "inputSpecification": "<p>The input consists of multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\leq t \\leq 100$$$) \u2014 the number of test cases.</p><p>The first line of each test case contains a single integer $$$n$$$ ($$$5 \\leq n \\leq 500$$$).</p><p>Then $$$2n$$$ lines followed. The $$$i$$$-th of these lines contains $$$n$$$ integers, representing the $$$i$$$-th array.</p><p>It is guaranteed, that the sum of $$$n$$$ over all test cases does not exceed $$$500$$$.</p>",
    "outputSpecification": "<p>For each test case print two lines.</p><p>In the first line, print the number of good subsets by modulo $$$998\\,244\\,353$$$.</p><p>In the second line, print $$$n$$$ indices from $$$1$$$ to $$$2n$$$ \u2014 indices of the $$$n$$$ arrays that form a good subset (you can print them in any order). If there are several possible answers \u2014 print any of them.</p>",
    "samples": [
        {
            "input": "\n3\n7\n1 2 3 4 5 6 7\n2 3 4 5 6 7 1\n3 4 5 6 7 1 2\n4 5 6 7 1 2 3\n5 6 7 1 2 3 4\n6 7 1 2 3 4 5\n7 1 2 3 4 5 6\n1 2 3 4 5 7 6\n1 3 4 5 6 7 2\n1 4 5 6 7 3 2\n1 5 6 7 4 2 3\n1 6 7 5 2 3 4\n1 7 6 2 3 4 5\n1 7 2 3 4 5 6\n5\n4 5 1 2 3\n3 5 2 4 1\n1 2 3 4 5\n5 2 4 1 3\n3 4 5 1 2\n2 3 4 5 1\n1 3 5 2 4\n4 1 3 5 2\n2 4 1 3 5\n5 1 2 3 4\n6\n2 3 4 5 6 1\n3 1 2 6 4 5\n6 1 2 3 4 5\n5 6 1 3 2 4\n4 3 6 5 2 1\n5 6 1 2 3 4\n4 5 6 1 2 3\n3 4 5 6 1 2\n1 2 3 4 5 6\n2 5 4 1 6 3\n3 2 5 4 1 6\n1 4 3 6 5 2\n",
            "output": "\n1\n1 2 3 4 5 6 7\n2\n1 3 5 6 10\n4\n1 3 6 7 8 9\n"
        }
    ],
    "note": "<p>In the first test case, the number of good subsets is $$$1$$$. The only such subset is the set of arrays with indices $$$1$$$, $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$, $$$6$$$, $$$7$$$.</p><p>In the second test case, the number of good subsets is $$$2$$$. They are $$$1$$$, $$$3$$$, $$$5$$$, $$$6$$$, $$$10$$$ or $$$2$$$, $$$4$$$, $$$7$$$, $$$8$$$, $$$9$$$.</p>",
    "contestId": 1545,
    "index": "C",
    "name": "AquaMoon and Permutations",
    "type": "PROGRAMMING",
    "tags": [
        "2-sat",
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "graph matchings",
        "graphs"
    ],
    "solvedCount": 592
}