{
    "title": "A. Accuracy-Preserving Summation Algorithm",
    "timeLimit": {
        "value": 10.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 1024.0,
        "unit": "megabytes"
    },
    "statement": "<p>In the classic high-performance computing domain (HPC), the vast majority of computations are conducted in double-precision 64-bit floating-point numbers (fp64, double-precision, IEEE-754 binary64). The rise of Deep Neural Networks (DNNs) resulted in hardware (HW) capable of processing 16-bit floating point numbers (fp16, half precision, IEEE-754 binary16) up to 16 times faster in terms of floating-point operations per second (flops) and up to 4 times faster in terms of memory bandwidth (BW). At the same time, the short mantissa and exponent for fp16 numbers lead to a very fast loss of precision of computations, producing wrong computational results without any option to recover them in reduction operations of size greater than approximately $$$2000$$$. As the typical problem size in HPC is much larger than $$$2000$$$, this makes fp16 computations almost useless. To surmount this major roadblock, smarter algorithms for reduction operations are needed.</p><p><span class=\"tex-font-style-bf\">Description.</span> There is a sequence of floating-point numbers stored in IEEE-754 binary64 (double precision, fp64) format $$$x_i$$$ of length $$$N$$$. The sequence needs to be summed up to $$$S = x_1 + x_2 + \\ldots + x_N$$$. As professional computer equipment with native support for fp16 is usually unavailable to the general audience, we propose to do operations in a simplified simulated environment, that is, we do computations in fp64 format with mantissa and exponent cut to the range admissible in fp16. In particular, small values that do not fit fp16 admissible range turn into zeros, while excessively large values turn into infinities. </p><p><span class=\"tex-font-style-bf\">Objective.</span> Your objective is to sum up as many sequences as possible as fast as possible and as accurately as possible. Please note that you may do summation in fp64 format, but the summation process would be slow though accurate. If you do plain summation in fp16 format, it can be fast, but inaccurate, especially for larger sequences.</p>",
    "inputSpecification": "<p>The input consists of a single line. It starts with an integer $$$N$$$ representing the number of values in the sequence. The following $$$N$$$ double precision numbers form the sequence $$$x_i$$$, where $$$i = 1, \\ldots, N$$$. </p><p><span class=\"tex-font-style-it\">Variable constraints:</span></p><ul> <li> Length of the sequence: $$$2 \\leq N \\leq 1\\,000\\,000$$$.</li><li> Value of any individual number in the sequence: legal IEEE-754 binary64 value stored in decimal format. </li></ul><p>Note that the actual binary64 value is not always exactly equal to the given decimal value. Instead, the actual given value is the closest number representable in binary64. When reading the input, most programming languages will do the conversion for you automatically.</p><p>It is guaranteed that every number in the sequence either is $$$0$$$ or has absolute value between $$$10^{-300}$$$ and $$$10^{300}$$$, inclusive.</p>",
    "outputSpecification": "<p>Print a single line which will describe the summation process. The line should contain an encoded algorithm for the summation. We use this encoding to do actual summation and report the result to prevent the need to seek hardware capable of doing fp16 operations natively.</p><p>An encoded algorithm consists of the data type to use, followed by a list of values to sum up using this data type. The result of the algorithm is the sum of the given values, as computed in the given data type, from left to right, in the given order. It looks as follows:</p><center> <span class=\"tex-font-style-tt\">{type:value_1,value_2,...,value_k}</span> </center><p>As you can see, the whole algorithm is surrounded by curly brackets (\"<span class=\"tex-font-style-tt\">{</span>\" and \"<span class=\"tex-font-style-tt\">}</span>\"). The next character represents one of the three possible data types: </p><ul> <li> \"<span class=\"tex-font-style-tt\">d</span>\" for fp64 summation, </li><li> \"<span class=\"tex-font-style-tt\">s</span>\" for fp32 summation, </li><li> \"<span class=\"tex-font-style-tt\">h</span>\" for fp16 summation. </li></ul><p>Then goes a colon (\"<span class=\"tex-font-style-tt\">:</span>\"). It is followed by a non-empty list of values to sum up, separated by commas (\"<span class=\"tex-font-style-tt\">,</span>\"). Note that there are no spaces.</p><p>Each value can be one of the following: </p><ul> <li> an integer from $$$1$$$ to $$$N$$$ indicating a position in the input sequence: in this case, the value comes directly from the input; </li><li> another algorithm: in this case, the value is the result of this algorithm. </li></ul><p>Some examples: </p><ul> <li> <span class=\"tex-font-style-tt\">{d:1,2,3,4}</span> tells to use double precision to compute $$$x_1 + x_2 + x_3 + x_4$$$; </li><li> <span class=\"tex-font-style-tt\">{h:4,3,2,1}</span> tells to use half precision to compute $$$x_4 + x_3 + x_2 + x_1$$$; </li><li> <span class=\"tex-font-style-tt\">{d:{s:3,4},{h:2,1}}</span> tells to use double precision to compute $$$y + z$$$, where: <ul> <li> $$$y$$$ is to use single precision to compute $$$x_3 + x_4$$$, </li><li> $$$z$$$ is to use half precision to compute $$$x_2 + x_1$$$; </li></ul> </li><li> <span class=\"tex-font-style-tt\">{h:1,4,{d:3,2}}</span> tells to use half precision to compute $$$x_1 + x_4 + y$$$, where: <ul> <li> $$$y$$$ is to use double precision to compute $$$x_3 + x_2$$$. </li></ul> </li></ul><p><span class=\"tex-font-style-bf\">Each input value must be used exactly once.</span></p>",
    "samples": [
        {
            "input": "\n<div class=\"test-example-line test-example-line-even test-example-line-0\">2 -4.815473e+04 -1.862622e+04</div>",
            "output": "\n{d:1,2}\n"
        },
        {
            "input": "\n<div class=\"test-example-line test-example-line-even test-example-line-0\">3 -4.815473e+01 1.862622e+02 2.997603e+02</div>",
            "output": "\n{d:1,2,3}\n"
        }
    ],
    "note": "<p>Two sets of tests are prepared in this problem: preliminary tests and final tests. For the duration of the competition, each submission is tested on the preliminary set of tests. When the competition is finished, for each contestant:</p><ul> <li> The jury takes the <span class=\"tex-font-style-bf\">latest</span> submission with <span class=\"tex-font-style-bf\">non-zero</span> score on preliminary tests.</li><li> This submission is tested on the final set of tests.</li><li> The contestants are ranked according to their performance on the final tests. </li></ul><p>The two sets of tests are designed to be similar, but not identical.</p>",
    "contestId": 1953,
    "index": "A",
    "name": "Accuracy-Preserving Summation Algorithm",
    "type": "PROGRAMMING",
    "tags": [
        "*special"
    ],
    "solvedCount": 0
}