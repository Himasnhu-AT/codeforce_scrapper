{
    "title": "D. Design Tutorial: Inverse the Problem",
    "timeLimit": {
        "value": 2.0,
        "unit": "seconds"
    },
    "memoryLimit": {
        "value": 256.0,
        "unit": "megabytes"
    },
    "statement": "<p>There is an easy way to obtain a new task from an old one called \"Inverse the problem\": we give an output of the original task, and ask to generate an input, such that solution to the original problem will produce the output we provided. The hard task of Topcoder Open 2014 Round 2C, InverseRMQ, is a good example.</p><p>Now let's create a task this way. We will use the task: you are given a tree, please calculate the distance between any pair of its nodes. Yes, it is very easy, but the inverse version is a bit harder: you are given an <span class=\"tex-span\"><i>n</i>\u2009\u00d7\u2009<i>n</i></span> distance matrix. Determine if it is the distance matrix of a weighted tree (all weights must be positive integers).</p>",
    "inputSpecification": "<p>The first line contains an integer <span class=\"tex-span\"><i>n</i></span> (<span class=\"tex-span\">1\u2009\u2264\u2009<i>n</i>\u2009\u2264\u20092000</span>) \u2014 the number of nodes in that graph.</p><p>Then next <span class=\"tex-span\"><i>n</i></span> lines each contains <span class=\"tex-span\"><i>n</i></span> integers <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\"><i>i</i>,\u2009<i>j</i></sub></span> (<span class=\"tex-span\">0\u2009\u2264\u2009<i>d</i><sub class=\"lower-index\"><i>i</i>,\u2009<i>j</i></sub>\u2009\u2264\u200910<sup class=\"upper-index\">9</sup></span>) \u2014 the distance between node <span class=\"tex-span\"><i>i</i></span> and node <span class=\"tex-span\"><i>j</i></span>.</p>",
    "outputSpecification": "<p>If there exists such a tree, output \"<span class=\"tex-font-style-tt\">YES</span>\", otherwise output \"<span class=\"tex-font-style-tt\">NO</span>\".</p>",
    "samples": [
        {
            "input": "3<br/>0 2 7<br/>2 0 9<br/>7 9 0<br/>",
            "output": "YES<br/>"
        },
        {
            "input": "3<br/>1 2 7<br/>2 0 9<br/>7 9 0<br/>",
            "output": "NO<br/>"
        },
        {
            "input": "3<br/>0 2 2<br/>7 0 9<br/>7 9 0<br/>",
            "output": "NO<br/>"
        },
        {
            "input": "3<br/>0 1 1<br/>1 0 1<br/>1 1 0<br/>",
            "output": "NO<br/>"
        },
        {
            "input": "2<br/>0 0<br/>0 0<br/>",
            "output": "NO<br/>"
        }
    ],
    "note": "<p>In the first example, the required tree exists. It has one edge between nodes 1 and 2 with weight 2, another edge between nodes 1 and 3 with weight 7.</p><p>In the second example, it is impossible because <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\">1,\u20091</sub></span> should be 0, but it is 1.</p><p>In the third example, it is impossible because <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\">1,\u20092</sub></span> should equal <span class=\"tex-span\"><i>d</i><sub class=\"lower-index\">2,\u20091</sub></span>.</p>",
    "contestId": 472,
    "index": "D",
    "name": "Design Tutorial: Inverse the Problem",
    "type": "PROGRAMMING",
    "tags": [
        "dfs and similar",
        "dsu",
        "shortest paths",
        "trees"
    ],
    "solvedCount": 5084
}